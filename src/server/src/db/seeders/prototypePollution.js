'use strict';

const artBody =
    '<h1>What is <span style="color: rgb(209,72,65);">prototype pollution</span>?</h1>\n<p></p>\n<p><span style="font-size: 16px;">Prototype pollution is an injection attack that targets JavaScript runtimes. With prototype pollution, an attacker might control the default values of an object\'s properties. This allows the attacker to tamper with the logic of the application and can also lead to denial of service or, in extreme cases, remote code execution.</span></p>\n<p></p>\n<p><span style="font-size: 16px;">After reading the above definition, there are probably at <em>least </em>a dozen questions that spring to mind. What does it actually mean to “override object attributes at runtime”? How can it affect the security of my application? And, most importantly, how do I protect my code against this attack?</span></p>\n<p></p>\n<p><span style="font-size: 16px;">So we need to take a slight detour and explain what JavaScript prototypes are.</span></p>\n<p><span style="font-size: 16px;">When we create an empty object in JavaScript (for example, </span><span style="color: rgb(209,72,65);font-size: 16px;"><code>const obj = {}</code></span><span style="font-size: 16px;">), the created object already has many attributes and methods defined for it, for instance, the </span><span style="color: rgb(209,72,65);font-size: 16px;"><code>toString</code></span><span style="font-size: 16px;"> method. Have you ever wondered where all these attributes and methods come from? The answer is the prototype.</span></p>\n<p></p>\n<p><span style="font-size: 16px;">Many object-oriented languages, for example Java, use classes as blueprints for object creation. Each object belongs to a class, and classes are organized in parent-child hierarchies. When we call the </span><span style="color: rgb(209,72,65);font-size: 16px;"><code>toString</code></span><span style="font-size: 16px;"> method on an object, the language runtime will look for the </span><span style="color: rgb(209,72,65);font-size: 16px;"><code>toString</code></span><span style="color: rgb(209,72,65);background-color: rgb(255,255,255);font-size: 16px;"><code> </code></span><span style="font-size: 16px;">method defined on the class a given object belongs to. If it cannot find such a definition, it will look for it in the parent class, then its parent class, until it hits the top of the class hierarchy.</span></p>\n<p></p>\n<p><span style="font-size: 16px;">JavaScript, instead, is a prototype-based object-oriented programming language. Each object is linked to a “prototype”. When we invoke the </span><span style="color: rgb(209,72,65);font-size: 16px;"><code>toString</code></span><span style="color: rgb(209,72,65);background-color: rgb(255,255,255);font-size: 16px;"><code> </code></span><span style="font-size: 16px;">method on an object, JavaScript will first check to see if we explicitly defined the method for the given object. If we haven’t, it will look for its definition on the object’s prototype.</span></p>\n<p></p>\n<h2>Prototype pollution explained!</h2>\n<p></p>\n<p>The bottom line is--<strong>if we modify a prototype shared by two or more objects, all objects will reflect this modification! </strong>They don’t even have to be in the same scope or otherwise related. And remember, most objects by default share the same prototype--so if we change the prototype of just one of these objects, we can change the behaviour of all of them!</p>\n<p>Example:</p>\n<pre>const a = {};<br>const b = new Object();<br>a.__proto__.x = 1337;<br>console.log(b.x); //1337</pre>\n<h2></h2>\n<h2>Prototype pollution secure</h2>\n<p>Merging two objects is not the only functionality that can expose the code to a prototype pollution attack—any function which recursively sets nested properties can create an attack vector. Other common examples in the JavaScript ecosystem include: deep cloning (e.g. <a href="https://lodash.com/docs#cloneDeep" target="_blank">lodash cloneDeep</a>), setting nested properties (e.g. <a href="https://lodash.com/docs#set" target="_blank">lodash set</a>), or creating objects by recursively "zipping" properties with values (e.g. <a href="https://lodash.com/docs#zipObjectDeep" target="_blank">lodash zipObjectDeep</a>).</p>\n<p></p>\n<p>There are different ways to fix this vulnerability, let\'s start with the most popular option.</p>\n<p></p>\n<h3><strong>Blacklist of fields</strong></h3>\n<p></p>\n<p>Most often, developers simply add <span style="color: rgb(209,72,65);"><strong>__proto__</strong></span> to the blacklist and do not copy this field. Even experienced developers do this.</p>\n<p></p>\n<p>Such a fix is easily circumvented by using <strong>constructor.prototype</strong> instead of <span style="color: rgb(209,72,65);"><strong>__proto__</strong></span>.</p>\n<p></p>\n<p>On the one hand, this method is easy to implement and is often enough to fix the vulnerability, on the other hand, it does not eradicate the problem, because there is still the possibility of changing <strong>Object.prototype</strong> and other prototypes.</p>\n<p></p>\n<pre>Object.create(null)</pre>\n<p></p>\n<p>You can use an object without a prototype, then modification of the prototype will be impossible.</p>\n<p></p>\n<pre>&gt; var o = Object.create(null)</pre>\n<pre>&lt; undefined</pre>\n<pre>&gt; o.__proto__</pre>\n<pre>&lt; undefined</pre>\n<p></p>\n<p></p>\n<p>The disadvantage is that further this object can break part of the functionality. For example, someone wants to call <strong>toString()</strong> on this object and will get o in response.toString is not a function.</p>\n<p></p>\n<h3><strong>Object.freeze()</strong></h3>\n<p></p>\n<p>Another option is to "freeze" Object.prototype using the Object function.freeze(). After that, Object.prototype cannot be modified.</p>\n<p></p>\n<p>However, there are several pitfalls:</p>\n<p></p>\n<p>Dependencies that modify Object.prototype may break.</p>\n<p>In general, you will have to freeze Array.prototype and other objects.</p>\n<p></p>\n';

module.exports = {
    async up(queryInterface, Sequelize) {
        let mockup = [];
        mockup.push({
            title: `Prototype pollution`,
            body: artBody,
            description:
                'Exposing the default prototype by calling unsafe recursive functions with untrusted data as input.',
            date_of_creation: new Date(),
            creatorid: '1',
            comments: '[]',
            createdAt: new Date(),
            updatedAt: new Date(),
        });
        await queryInterface.bulkInsert('Articles', mockup, {});
    },

    async down(queryInterface, Sequelize) {
        await queryInterface.bulkDelete('Articles', null, {});
    },
};
